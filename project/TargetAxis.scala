import sbt._
import sbt.internal.ProjectMatrix
import sbtprojectmatrix.ProjectMatrixPlugin.autoImport._

/** Use on ProjectMatrix rows to tag an affinity to a custom scalaVersion */
case class TargetAxis(scalaVersion: String) extends VirtualAxis.WeakAxis {

  override val idSuffix = s"Target${scalaVersion.replace('.', '_')}"
  override val directorySuffix = s"target$scalaVersion"
  override val suffixOrder = VirtualAxis.scalaABIVersion("any").suffixOrder + 1
}

object TargetAxis {

  def targetScalaVersion(virtualAxes: Seq[VirtualAxis]): Option[String] =
    virtualAxes.collectFirst { case a: TargetAxis => a.scalaVersion }

  /**
   * When invoked on a ProjectMatrix with a TargetAxis, lookup the project
   * generated by `matrix` with a scalaVersion matching the one declared in that
   * TargetAxis, and resolve `key`.
   */
  def resolve[T](
      matrix: ProjectMatrix,
      key: TaskKey[T]
  ): Def.Initialize[Task[T]] =
    Def.taskDyn {
      val sv = targetScalaVersion(virtualAxes.value).get
      val project = exactOrBinaryScalaVersionMatch(matrix, sv)
      Def.task((project / key).value)
    }

  /**
   * When invoked on a ProjectMatrix with a TargetAxis, lookup the project
   * generated by `matrix` with a scalaVersion matching the one declared in that
   * TargetAxis, and resolve `key`.
   */
  def resolve[T](
      matrix: ProjectMatrix,
      key: SettingKey[T]
  ): Def.Initialize[T] =
    Def.settingDyn {
      val sv = targetScalaVersion(virtualAxes.value).get
      val project = exactOrBinaryScalaVersionMatch(matrix, sv)
      Def.setting((project / key).value)
    }

  private def exactOrBinaryScalaVersionMatch(
      matrix: ProjectMatrix,
      scalaVersion: String
  ): Project = {
    val projectsWithAxisValues = matrix.allProjects().flatMap {
      case (p, axisValues) => axisValues.map(v => (p, v))
    }

    projectsWithAxisValues.collectFirst {
      case (p, VirtualAxis.ScalaVersionAxis(_, value))
          if value == scalaVersion ||
            value == CrossVersion.binaryScalaVersion(scalaVersion) =>
        p
    }.get
  }

  implicit class TargetProjectMatrix(projectMatrix: ProjectMatrix) {

    /** Like jvmPlatform but with the full scala version attached */
    def jvmPlatformFull(scalaVersions: Seq[String]): ProjectMatrix = {
      scalaVersions.foldLeft(projectMatrix) { (acc, sv) =>
        acc.customRow(
          autoScalaLibrary = true,
          axisValues = Seq(
            VirtualAxis.jvm,
            VirtualAxis.scalaVersionAxis(sv, sv)
          ),
          process = p => p
        )
      }
    }

    /**
     * Like jvmPlatform but adding a target axis with the scala version provided
     * as the second element of the tuple
     */
    def jvmPlatformWithTargets(
        buildWithTargetVersions: Seq[(String, String)]
    ): ProjectMatrix = {
      buildWithTargetVersions.foldLeft(projectMatrix) {
        case (acc, (build, target)) =>
          acc.jvmPlatform(
            scalaVersions = Seq(build),
            axisValues = Seq(TargetAxis(target)),
            settings = Seq()
          )
      }
    }

  }

}
